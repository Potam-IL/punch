#!/usr/bin/python
# vi: set et ts=4 sw=4 :
"""
Copyright (c) 2012, Jeremy W. Sherman
All rights reserved.

Distributed under the 3-clause BSD license.
See LICENSE at https://github.com/jeremy-w/punch.

Punch is a commandline time tracking tool.
Punch is:

- simple
- minimal

Punch's file format:

- human-readable, -editable, and -comprehensible
- easily computer-readable, -editable, and -comprehensible
- uses ISO 8601 formatting and UTC throughout
- Unicode-friendly thanks to UTF-8
"""
import codecs
from datetime import datetime
import re


class Task(object):
    """A task represents a space-free name,
    a start time and duration, and an optional free-form comment.

    The start time is stored as a datetime.
    Duration is in seconds.

    Use ISO to format this info.
    Use TaskStream to read or write tasks.
    """
    def __init__(self, name, start, duration, comment=u''):
        self.name = unicode(name)
        self.start = start
        self.duration = float(duration)
        self.comment = unicode(comment)


class TaskStream(object):
    """Task streams handle reading and writing tasks as strings.
    Each task is a single line.
    Blank lines and lines beginning with a # are skipped when reading.
    """
    # Three possible formats:
    # - timeless: name or name / comment, used in the tasks file
    # - timed: name start/duration comment?, used everywhere else
    # The real distinguishing factor of the timeless version is the
    # lack of characters before the /, where the start would be.
    timeless_regex = re.compile(r"""^(?:
          (?P<name> \S+ )
          (?: \s+ / \s* (?P<comment> .* ) )?
        )$""", re.U | re.X)
    timed_regex = re.compile(r"""^(?:
          (?P<name> \S+ ) \s+
          (?P<start> \S+ )/(?P<duration> \S+ )
          (?: \s+ (?P<comment> .+ ))?
          )$""", re.U | re.X)

    timeless_format = u"%s / %s"   # name and comment
    timed_format = u"%s %s/%s %s"  # name, start, duration, comment

    @classmethod
    def read(cls, fileobj):
        """Reads a list of tasks from fileobj.
        Line parsing is done by TaskStream.parse().

        fileobj should be created by codecs.open(path, mode, 'utf-8').

        Raises FormatError on invalid task format.
        """
        tasks = []
        lineno = 0
        for line in fileobj:
            lineno += 1
            task = cls.parse(line, lineno)
            if task: tasks.append(task)
        return tasks

    @classmethod
    def write(cls, tasks, fileobj):
        """Writes a sequence of tasks to fileobj.

        fileobj should be created by codecs.open(path, mode, 'utf-8').
        """
        for task in tasks:
            string = cls.format(task) + u"\n"
            fileobj.write(string)

    @classmethod
    def parse(cls, line, lineno=None):
        """Parses a task from a line of text.

        Raises whatever ISO.to_datetime() or ISO.duration_to_seconds() raise.
        Raises FormatError on invalid datetime or duration format.
        """
        line = line.strip()
        if not line or line.startswith('#'):
            return None

        match = cls.timeless_regex.match(line) or\
            cls.timefree_regex.match(line)
        if not match:
            raise FormatError("bad task format", line, lineno)

        name = match.group('name')
        start = match.group('start')
        if start: start = ISO.to_datetime(start)
        duration = match.group('duration')
        if duration: duration = ISO.duration_to_seconds(duration)
        comment = match.group('comment') or u''
        task = Task(name, start, duration, comment)
        return task

    @classmethod
    def format(cls, task):
        """Formats a task for writing.

        Returns a unicode string.

        Raises Error if task.name is empty.
        Raises FormatError if start or duration cannot be formatted."""
        name = task.name.strip()
        start = task.start
        duration = task.duration
        comment = task.comment

        if not name:
            raise Error("a task must have a name")
        if start:
            start = ISO.from_datetime(start)
            if not duration: duration = 0
        if duration: duration = ISO.seconds_to_duration(duration)

        string = cls.timed_format % (name, start, duration, comment) if start\
            else cls.timeless_format % (name, comment)
        return string.strip()


class ISO(object):
    """ISO handles conversion between formatted strings and
    datetimes (for date-times) and floats (for durations).

    ISO only creates a duration with components of accurate duration (hour,
    minute, second, but supports reading durations with components of nominal
    duration (year, month, day) by assuming 24 hours per day, 30 days per
    month, and 12 months per year.
    """

    isodatetime_regex = re.compile(
        r"""(?P<year> \d{4} ) - (?P<month> \d{2} ) - (?P<day> \d{2} )
        T (?P<hour> \d{2} ) : (?P<minute> \d{2} ) : (?P<second> \d{2} ) Z?""",
        re.U | re.X)
    isoduration_regex = re.compile(
        r"""P (?:(?P<Y> \d* )Y)? (?:(?P<M> \d+ )M)? (?:(?P<D> \d+ )D)?
        (?:T (?:(?P<TH> \d+ )H)? (?:(?P<TM> \d+ )M)? (?:(?P<TS> \d+ )S)?)?""",
        re.U | re.X)
    isodatetime_format = u"%04d-%02d-%02dT%02d:%02d:%02dZ"

    @classmethod
    def to_datetime(cls, isostring):
        """Returns the datetime corresponding to an ISO-8601 date-time string.

        Raises FormatError if the string format is bad."""
        match = cls.isodatetime_regex.match(isostring)
        if not match:
            raise FormatError("expected UTC ISO 8601 datetime", isostring)

        group = match.groupdict()
        dt = datetime(group['year'], group['month'], group['day'],
            group['hour'], group['minute'], group['second'])
        return dt

    @staticmethod
    def from_datetime(datetime):
        """Returns an ISO-8601-formatted string corresponding to datetime."""
        parts = (datetime.year, datetime.month, datetime.day,
            datetime.hour, datetime.minute, datetime.second)
        string = cls.isodatetime_format % parts
        return string

    @classmethod
    def duration_to_seconds(cls, isostring):
        """Returns a float representing the total seconds of the
        ISO-8601-formatted duration isostring.

        Raises FormatError on bad string format.
        """
        match = cls.isoduration_regex.match(isostring)
        # ISO 8601:2004(E) 4.4.3.2(c):
        # "at least one number and its designator shall be present"
        if not match or not match.groups():
            raise FormatError("expected UTC ISO 8601 duration", isostring)
        group = match.groupdict()
        year = group['Y'] or 0
        month = group['M'] or 0
        day = group['D'] or 0
        hour = group['TH'] or 0
        minute = group['TM'] or 0
        second = group['TS'] or 0
        seconds = second + 60*(minute + 60*(hour +
            24*(day + 30*(month + 12*year))))
        return seconds

    @staticmethod
    def seconds_to_duration(seconds):
        """Returns a unicode string of the ISO-8601-formatted duration
        corresponding to seconds.
        """
        minute, second = divmod(seconds, 60)
        hour, minute = divmod(minute, 60)
        parts = [u"PT"]
        if hour: parts.append(u"%02dH" % hour)
        if minute: parts.append(u"%02dM" % minute)
        # We have to have at least one unit, so ensure that there's at least
        # seconds, even if it's just 00S.
        parts.append(u"%02dS" % second)
        return u"".join(parts)


class Path(object):
    """Path is a place to stuff all the paths used by punch.
    A single global instance exists at runtime."""
    pass


class Error(Exception):
    """Parent class of all exceptions thrown by punch."""
    pass


class FormatError(Error):
    def __init__(self, message, line=None, lineno=None):
        self.message = message
        self.line = line
        self.lineno = lineno

    def __str__(self):
        parts = [self.line]
        if self.lineno:
            parts.insert(self.lineno, 0)
        if self.line:
            parts.append(self.line)
        return u": ".join(parts)
