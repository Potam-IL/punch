#!/usr/bin/python
# vi: set et ts=4 sw=4 :
"""
Copyright (c) 2012, Jeremy W. Sherman
All rights reserved.

Distributed under the 3-clause BSD license.
See LICENSE at https://github.com/jeremy-w/punch.

Punch is a commandline time tracking tool.
Punch is:

- simple
- minimal

Punch's file format:

- human-readable, -editable, and -comprehensible
- easily computer-readable, -editable, and -comprehensible
- uses ISO 8601 formatting and UTC throughout
- Unicode-friendly thanks to UTF-8
"""
import argparse
from datetime import datetime, timedelta
import fnmatch
import io
import math
import os
import re
from StringIO import StringIO
import shutil
import sys


class Task(object):
    """A task represents a space-free name,
    a start time and duration, and an optional free-form comment.

    The start time is stored as a datetime.
    Duration is in seconds.
    Comment is optional and defaults to the empty unicode string.

    Use ISO to format this info.
    Use TaskStream to read or write tasks.
    """
    def __init__(self, name, start=None, duration=None, comment=u''):
        self.name = unicode(name)
        self.start = start
        self.duration = float(duration) if duration else None
        self.comment = unicode(comment) if comment else u''
        self.is_comment = name is None

    @classmethod
    def comment(cls, comment):
        """Creates a new comment task - a task that is purely a comment."""
        return cls(name=None, comment=comment)

    def __str__(self):
        """Returns a string with the elapsed time, name, and comment.

        Used when presenting a task to the user in response to an interactive
        command.
        """
        if self.is_comment:
            return self.comment
        s = self.duration
        m, s = divmod(s, 60)
        h, m = divmod(m, 60)
        s = round(s)
        time = u'- '
        if h > 0:
            time = u'%dh%02dm%02ds ' % (h, m, s)
        elif m > 0 or s > 0:
            time = u'%dm%02ds ' % (m, s)
        return u'%s%s (%s)' % (time, self.name, self.comment)

    def __repr__(self):
        return u'Task(name=%s, start=%s, duration=%s, comment=%s)'\
            % (self.name, self.start, self.duration, self.comment)


class TaskStream(object):
    """Task streams handle reading and writing tasks as strings.
    Each task is a single line.
    Blank lines and lines beginning with a # are skipped when reading.
    """
    # Three possible formats:
    # - timeless: name or name / comment, used in the tasks file
    # - timed: name start/duration comment?, used everywhere else
    # The real distinguishing factor of the timeless version is the
    # lack of characters before the /, where the start would be.
    timeless_regex = re.compile(r"""^(?:
          (?P<name> \S+ )
          (?: \s+ / \s* (?P<comment> .* ) )?
        )$""", re.U | re.X)
    timed_regex = re.compile(r"""^(?:
          (?P<name> \S+ ) \s+
          (?P<start> \S+ )/(?P<duration> \S+ )
          (?: \s+ (?P<comment> .+ ))?
          )$""", re.U | re.X)

    timeless_format = u"%s / %s"   # name and comment
    timed_format = u"%s %s/%s %s"  # name, start, duration, comment

    @classmethod
    def read(cls, fileobj):
        """Reads a list of tasks from fileobj.
        Line parsing is done by TaskStream.parse().

        fileobj should be created by io.open(path, mode, encoding='utf-8').

        Raises FormatError on invalid task format.
        """
        tasks = []
        lineno = 0
        for line in fileobj:
            lineno += 1
            task = cls.parse(line, lineno)
            if task: tasks.append(task)
        return tasks

    @classmethod
    def write(cls, fileobj, *tasks):
        """Writes a sequence of tasks to fileobj.

        fileobj should be created by io.open(path, mode, encoding='utf-8').
        """
        for task in tasks:
            string = cls.format(task) + u"\n"
            fileobj.write(string)

    @classmethod
    def parse(cls, line, lineno=None):
        """Parses a task from a line of text.

        Raises whatever ISO.to_datetime() or ISO.duration_to_seconds() raise.
        Raises FormatError on invalid datetime or duration format.
        """
        line = line.strip()
        if not line or line.startswith('#'):
            return Task.comment(comment=line)

        match = cls.timeless_regex.match(line) or\
            cls.timed_regex.match(line)
        if not match:
            raise FormatError("bad task format", line, lineno)

        group = match.groupdict()
        name = group.get('name')
        start = group.get('start')
        if start: start = ISO.to_datetime(start)
        duration = group.get('duration')
        if duration: duration = ISO.duration_to_seconds(duration)
        comment = group.get('comment') or u''
        task = Task(name, start, duration, comment)
        return task

    @classmethod
    def format(cls, task):
        """Formats a task for writing.

        Returns a unicode string.

        Raises Error if task.name is empty but not task.is_comment.
        Raises FormatError if start or duration cannot be formatted."""
        if task.is_comment:
            return task.comment
        name = task.name.strip()
        start = task.start
        duration = task.duration
        comment = task.comment

        if not name:
            raise Error("a task must have a name")
        if start:
            start = ISO.from_datetime(start)
            if not duration: duration = 0
        if duration is not None:
            duration = ISO.seconds_to_duration(duration)

        string = cls.timed_format % (name, start, duration, comment) if start\
            else cls.timeless_format % (name, comment)
        return string.strip()


class ISO(object):
    """ISO handles conversion between formatted strings and
    datetimes (for date-times) and floats (for durations).
    It also handles converting between duration formats.

    ISO only creates a duration with components of accurate duration (hour,
    minute, second, but supports reading durations with components of nominal
    duration (year, month, day) by assuming 24 hours per day, 30 days per
    month, and 12 months per year.
    """

    isodatetime_regex = re.compile(
        r"""(?P<year> \d{4} ) - (?P<month> \d{2} ) - (?P<day> \d{2} )
        T (?P<hour> \d{2} ) : (?P<minute> \d{2} ) : (?P<second> \d{2} ) Z?""",
        re.U | re.X)
    isoduration_regex = re.compile(
        r"""P (?:(?P<Y> \d* )Y)? (?:(?P<M> \d+ )M)? (?:(?P<D> \d+ )D)?
        (?:T (?:(?P<TH> \d+ )H)? (?:(?P<TM> \d+ )M)? (?:(?P<TS> \d+ )S)?)?""",
        re.U | re.X)
    isodatetime_format = u"%04d-%02d-%02dT%02d:%02d:%02dZ"

    @classmethod
    def to_datetime(cls, isostring):
        """Returns the datetime corresponding to an ISO-8601 date-time string.

        Raises FormatError if the string format is bad."""
        match = cls.isodatetime_regex.match(isostring)
        if not match:
            raise FormatError("expected UTC ISO 8601 datetime", isostring)

        group = match.groupdict()
        vals = [group['year'], group['month'], group['day'],
            group['hour'], group['minute'], group['second']]
        vals = [int(val) for val in vals]
        dt = datetime(*vals)
        return dt

    @classmethod
    def from_datetime(cls, datetime):
        """Returns an ISO-8601-formatted string corresponding to datetime."""
        parts = (datetime.year, datetime.month, datetime.day,
            datetime.hour, datetime.minute, datetime.second)
        string = cls.isodatetime_format % parts
        return string

    @classmethod
    def duration_to_seconds(cls, isostring):
        """Returns a float representing the total seconds of the
        ISO-8601-formatted duration isostring.

        Raises FormatError on bad string format.
        """
        match = cls.isoduration_regex.match(isostring)
        # ISO 8601:2004(E) 4.4.3.2(c):
        # "at least one number and its designator shall be present"
        if not match or not match.groups():
            raise FormatError("expected UTC ISO 8601 duration", isostring)
        group = match.groupdict()
        year = int(group['Y'] or 0)
        month = int(group['M'] or 0)
        day = int(group['D'] or 0)
        hour = int(group['TH'] or 0)
        minute = int(group['TM'] or 0)
        second = float(group['TS'] or 0.0)
        seconds = second + 60.0*(minute + 60.0*(hour +
            24.0*(day + 30.0*(month + 12.0*year))))
        return seconds

    @staticmethod
    def seconds_to_duration(seconds):
        """Returns a unicode string of the ISO-8601-formatted duration
        corresponding to seconds.
        """
        minute, second = divmod(seconds, 60)
        hour, minute = divmod(minute, 60)
        parts = [u"PT"]
        if hour: parts.append(u"%02dH" % hour)
        if minute: parts.append(u"%02dM" % minute)
        # We have to have at least one unit, so ensure that there's at least
        # seconds, even if it's just 00S.
        parts.append(u"%02dS" % second)
        return u"".join(parts)

    @staticmethod
    def duration(start=None, stop=None, duration=None):
        """Supply any two, it computes and returns the third.

        start and stop should be Python datetimes.
        duration should be a Python float.

        Raises Error if other than 2 args are supplied."""
        count = len([a for a in [start, stop, duration] if a is not None])
        if count != 2:
            raise Error(u"ISO.duration: expected exactly 2 args, %d supplied"\
                % count)
        if not start:
            start = stop + timedelta(seconds=-duration)
            return start
        if not stop:
            stop = start + timedelta(seconds=duration)
            return stop
        if not duration:
            delta = stop - start
            duration = delta.seconds + 3600*delta.days
            if delta.microseconds:
                duration += 1
            return duration


class Path(object):
    """Path is a place to stuff all the paths used by punch."""

    HOME = unicode(os.getenv("HOME", u"~"))
    """The user's home directory."""

    PUNCH_DIR_DEFAULT = os.path.join(HOME, u".punch/")
    """The default root directory $PUNCHDIR (normally ~/.punch)."""

    PUNCH_DIR = unicode(os.getenv("PUNCH_DIR", PUNCH_DIR_DEFAULT))
    """The root directory - default can be overridden by environment."""

    def __init__(self, tasks=u"tasks", times=u"times", current=u"current",\
        root=PUNCH_DIR):
        """Returns a new Path instance.

        Assigns root/{tasks,times,current} to the
        tasks, times, and current attributes.

        If root is None, uses PUNCH_DIR.
        """
        self.root = root if root else type(self).PUNCH_DIR
        self.tasks = os.path.join(self.root, tasks)
        self.times = os.path.join(self.root, times)
        self.current = os.path.join(self.root, current)

    def __repr__(self):
        return u'Path(tasks=%s, times=%s, current=%s, root=%s)'\
            % (self.tasks, self.times, self.current, self.root)

    @staticmethod
    def backup(path):
        """Backs up 'path' to '.path~'.

        Does nothing if path does not exist.
        """
        if not os.path.exists(path):
            return
        parent = os.path.dirname(path)
        fnam = os.path.basename(path)
        target_name = u''.join(['.', fnam, '~'])
        target_path = os.path.join(parent, target_name)
        shutil.copy2(path, target_path)


class Error(Exception):
    """Parent class of all exceptions thrown by punch."""
    pass


class FormatError(Error):
    def __init__(self, message, line=None, lineno=None):
        self.message = message
        self.line = line
        self.lineno = unicode(lineno) if lineno else None

    def __str__(self):
        """Returns FormatError formatted as an error message:
            lineno: message: line
        Components of this message will be omitted if not provided.
        """
        parts = [self.message]
        if self.lineno:
            parts.insert(0, self.lineno)
        if self.line:
            parts.append(self.line)
        return u": ".join(parts)

    def __repr__(self):
        return u'FormatError(message=%s, line=%s, lineno=%s)'\
            % (self.message, self.line, self.lineno)


class Core(object):
    """Layer over Task, TaskStream, and Path."""
    def __init__(self, path=Path()):
        """Creates a new Core object."""
        self.path = path

    def current_task(self):
        """Returns the first (and only) task in self.path.current
        after updating its duration to match the current time.

        Returns None if the file does not exist or is empty.
        """
        if not os.path.isfile(self.path.current):
            return None
        with io.open(self.path.current, 'r', encoding='utf-8') as f:
            tasks = TaskStream.read(f)
            tasks = [t for t in tasks if not t.is_comment]
            if tasks:
                task = tasks[0]
                task.duration = ISO.duration(task.start, datetime.utcnow())
                return task
            return None

    def write_task_to_path(self, task, path, backup=True):
        """Writes |task| over |path|."""
        if backup: Path.backup(path)
        with io.open(path, 'w', encoding='utf-8') as f:
            TaskStream.write(f, task)

    def append_task_to_path(self, task, path):
        """Appends |task| to |path|."""
        with io.open(path, 'a', encoding='utf-8') as f:
            TaskStream.write(f, task)

    def read_tasks(self, path):
        """Returns all tasks in path.

        If an error is raised, prints it to stderr and returns None."""
        with io.open(self.path.tasks, 'r', encoding='utf-8') as f:
            tasks = []
            try:
                tasks = TaskStream.read(f)
                return tasks
            except Error as e:
                print >>sys.stderr, u'%s: error: %s:%s'\
                    % (self.prog, path, e)
                return None

    @staticmethod
    def tasks_matching_globs(tasks, globs):
        """Returns the list of tasks whose names match any of globs."""
        matches = []
        for glob in globs:
            matches += [t for t in tasks if fnmatch.fnmatch(t.name, glob)]
        return matches


class Punch(object):
    """Carries out the standard punch operations."""

    def __init__(self, path=Path()):
        """Creates self.parser and creates path.root."""
        desc = u"The time tracker distinguished by its good taste."
        self.parser = argparse.ArgumentParser(description=desc)
        self.prog = self.parser.prog
        subparsers = self.parser.add_subparsers()

        self.path = path
        if not os.path.exists(path.root):
            try:
                os.mkdir(path.root)
            except OSError as e:
                print >>sys.stderr,\
                    u"%s: error: cannot create punch directory %s: %s"\
                    % (self.prog, self.path.root, e)

        self.core = Core(path)

        self.add_tasks_parser(subparsers)
        self.add_times_parser(subparsers)
        in_parser = subparsers.add_parser('in')
        in_parser.set_defaults(run=self.punch_in_glob)
        in_parser.add_argument('nameglob', nargs='?', type=unicode,
            help="the task to check in for - "
            "multiple matches will be presented in a list;"
            "omit to choose from all tasks."
            "If you are already punched in, you will be punched out first.")

        out_parser = subparsers.add_parser('out')
        out_parser.set_defaults(run=self.punch_out)

    def add_tasks_parser(self, subparsers):
        """Adds the parser tree responsible for handling
        `punch tasks` to |subparsers|.
        """
        tasks_parser = subparsers.add_parser('tasks')
        tasks_parsers = tasks_parser.add_subparsers()

        tasks_list_parser = tasks_parsers.add_parser('list')
        tasks_list_parser.set_defaults(run=self.tasks_list)

        tasks_add_parser = tasks_parsers.add_parser('add')
        tasks_add_parser.set_defaults(run=self.tasks_add)
        tasks_add_parser.add_argument('name', type=unicode,
            help="the new task's name - any space will be replaced by '-'")
        tasks_add_parser.add_argument('comment', nargs='*', type=unicode,
            help="the new task's comment (one line)")

        tasks_remove_parser = tasks_parsers.add_parser('remove')
        tasks_remove_parser.set_defaults(run=self.tasks_remove)
        tasks_remove_parser.add_argument('nameglob', nargs='+', type=unicode,
            help="the name of the task or tasks to remove")
        tasks_remove_parser.add_argument('--force', '-f', action='store_true',
            help="do not confirm the tasks to be removed")

    def add_times_parser(self, subparsers):
        """Adds the parser tree responsible for handling
        `punch times` to |subparsers|.
        """
        print "TODO: add_times_parser"

    def punch_in_glob(self, args):
        """Reduces args to a single task and calls punch_in(task)
        after punching out any existing current task.
        """
        tasks = self.core.read_tasks(self.path.tasks)
        logged_error = tasks is None
        if logged_error: return
        if not tasks:
            print u'%s: no tasks found -- add some with `%s tasks add`'\
                % (self.prog, self.prog)
            return

        matches = self.core.tasks_matching_globs(tasks, [args.nameglob])\
            if args.nameglob else tasks
        if not matches:
            print u'%s: no task names match %s'\
                % (self.prog, args.nameglob)
            return
        count = len(matches)

        buf = StringIO()
        template = u'%%%dd: %%s\n' % (math.log(count, 10))
        for i, task in enumerate(matches):
            buf.write(template % (i + 1, task))
        buf.write(u'%s: enter a number to select a task: '\
            % (self.prog))
        val = raw_input(buf.getvalue())
        buf.close()

        # validate val to get index
        if not val:
            print u'%s: aborted' % (self.prog)
            return
        index = 0
        try:
            index = int(val) - 1
        except ValueError:
            print u'%s: error: not a number: %s' % (self.prog, val)
            return
        if not 0 <= index < count:
            print u'%s: error: must select 1-%d, not %d'\
                % (self.prog, count, index + 1)

        task = matches[index]
        current = self.core.current_task()
        if current:
            if task.name == current.name:
                print u'%s: already punched in: %s'\
                    % (self.prog, current)
                return
            self.punch_out()

        task.start = datetime.utcnow().replace(microsecond=0)
        self.core.write_task_to_path(task, self.path.current)
        print u'%s: punched in: %s'\
            % (self.prog, task)

    def punch_out(self, args):
        """Appends the task from self.path.current to self.path.times
        and then removes self.path.current.
        """
        task = self.core.current_task()
        if not task:
            print u'%s: no current task to punch out' % (self.prog)
            return

        # We follow the task with a comment containing
        # the local date, hours (rounded to the half-hour), and total seconds.
        # This makes building a summary with an external tool easier.
        comment = u'#^ local %s : %0.3f h = %d s'
        local_stop = datetime.now()
        local_start = ISO.duration(stop=local_stop, duration=task.duration)
        local_date = local_start.date().isoformat()
        secs = round(task.duration)
        hours = float(secs) / 3600.0
        comment = comment % (local_date, hours, secs)
        comment_task = Task.comment(comment)

        with io.open(self.path.times, 'a', encoding='utf-8') as f:
            TaskStream.write(f, task, comment_task)

        # Already copied sole entry to self.path.times,
        # so no need to make another backup before unlinking.
        os.unlink(self.path.current)
        print u'%s: punched out: %s' % (self.prog, task)

    def handle(self, args):
        """Handles args as if provided on the commandline."""
        if not args:
            self.list_current()
            return
        args = self.parser.parse_args(args)
        args.run(args)

    def list_current(self):
        """Lists the current task.

        This is the default behavior when invoked with no args."""
        task = self.core.current_task()
        if task:
            print u'%s: current task: %s' % (self.prog, task)
        else:
            print u'%s: no current task' % (self.prog)

    def tasks_list(self, args):
        tasks = self.core.read_tasks(self.path.tasks)
        logged_error = tasks is None
        if logged_error: return
        if not tasks:
            print u'%s: no tasks found -- add some with `%s tasks add`'\
                % (self.prog, self.prog)
        for task in tasks:
            print str(task)

    def tasks_add(self, args):
        task = Task(name=args.name, comment=args.comment)
        desc = TaskStream.format(task)
        self.core.append_task_to_path(task, self.path.tasks)
        print u'%s: added task: %s' % (self.prog, desc)

    def tasks_remove(self, args):
        tasks = self.core.read_tasks(self.path.tasks)
        if tasks is None:
            return

        to_remove = self.core.tasks_matching_globs(tasks, args.nameglob)
        count = len(to_remove)
        if not count:
            print u'%s: no task names match %s'\
                % (self.prog, u' '.join(*args.nameglob))
            return

        if not args.force:
            buf = StringIO()
            header = u'%s: found %d:\n' % (self.prog, count)
            buf.write(header)
            for task in to_remove:
                buf.write('    %s\n' % (TaskStream.format(task)))
            prompt = u'%s: (r)emove or (N)ot? ' % (self.prog)
            buf.write(prompt)
            reply = raw_input(buf.getvalue()).strip()
            buf.close()
            if not (reply and reply[0].lower() == 'r'):
                print u'%s: aborted' % (self.prog)
                return

        remainder = list(tasks)
        for task in to_remove:
            remainder.remove(task)
        Path.backup(self.path.tasks)
        with io.open(self.path.tasks, 'w', encoding='utf-8') as f:
            TaskStream.write(f, *remainder)
        print u'%s: removed %d' % (self.prog, count)


def main():
    punch = Punch()
    try:
        punch.handle(sys.argv[1:])
    except KeyboardInterrupt:
        return


if __name__ == "__main__":
    main()
