#!/usr/bin/python
# vi: set et ts=4 sw=4 :
"""
Copyright (c) 2012, Jeremy W. Sherman
All rights reserved.

Distributed under the 3-clause BSD license.
See LICENSE at https://github.com/jeremy-w/punch.

Punch is a commandline time tracking tool.
Punch is:

- simple
- minimal

Punch's file format:

- human-readable, -editable, and -comprehensible
- easily computer-readable, -editable, and -comprehensible
- uses ISO 8601 formatting and UTC throughout
- Unicode-friendly thanks to UTF-8
"""
import argparse
import codecs
from datetime import datetime
import os
import re
import sys


class Task(object):
    """A task represents a space-free name,
    a start time and duration, and an optional free-form comment.

    The start time is stored as a datetime.
    Duration is in seconds.

    Use ISO to format this info.
    Use TaskStream to read or write tasks.
    """
    def __init__(self, name, start, duration, comment=u''):
        self.name = unicode(name)
        self.start = start if start else datetime.utcnow()
        self.duration = float(duration) if duration else 0
        self.comment = unicode(comment) if comment else u''


class TaskStream(object):
    """Task streams handle reading and writing tasks as strings.
    Each task is a single line.
    Blank lines and lines beginning with a # are skipped when reading.
    """
    # Three possible formats:
    # - timeless: name or name / comment, used in the tasks file
    # - timed: name start/duration comment?, used everywhere else
    # The real distinguishing factor of the timeless version is the
    # lack of characters before the /, where the start would be.
    timeless_regex = re.compile(r"""^(?:
          (?P<name> \S+ )
          (?: \s+ / \s* (?P<comment> .* ) )?
        )$""", re.U | re.X)
    timed_regex = re.compile(r"""^(?:
          (?P<name> \S+ ) \s+
          (?P<start> \S+ )/(?P<duration> \S+ )
          (?: \s+ (?P<comment> .+ ))?
          )$""", re.U | re.X)

    timeless_format = u"%s / %s"   # name and comment
    timed_format = u"%s %s/%s %s"  # name, start, duration, comment

    @classmethod
    def read(cls, fileobj):
        """Reads a list of tasks from fileobj.
        Line parsing is done by TaskStream.parse().

        fileobj should be created by codecs.open(path, mode, 'utf-8').

        Raises FormatError on invalid task format.
        """
        tasks = []
        lineno = 0
        for line in fileobj:
            lineno += 1
            task = cls.parse(line, lineno)
            if task: tasks.append(task)
        return tasks

    @classmethod
    def write(cls, tasks, fileobj):
        """Writes a sequence of tasks to fileobj.

        fileobj should be created by codecs.open(path, mode, 'utf-8').
        """
        for task in tasks:
            string = cls.format(task) + u"\n"
            fileobj.write(string)

    @classmethod
    def parse(cls, line, lineno=None):
        """Parses a task from a line of text.

        Raises whatever ISO.to_datetime() or ISO.duration_to_seconds() raise.
        Raises FormatError on invalid datetime or duration format.
        """
        line = line.strip()
        if not line or line.startswith('#'):
            return None

        match = cls.timeless_regex.match(line) or\
            cls.timed_regex.match(line)
        if not match:
            raise FormatError("bad task format", line, lineno)

        group = match.groupdict()
        name = group.get('name')
        start = group.get('start')
        if start: start = ISO.to_datetime(start)
        duration = group.get('duration')
        if duration: duration = ISO.duration_to_seconds(duration)
        comment = group.get('comment') or u''
        task = Task(name, start, duration, comment)
        return task

    @classmethod
    def format(cls, task):
        """Formats a task for writing.

        Returns a unicode string.

        Raises Error if task.name is empty.
        Raises FormatError if start or duration cannot be formatted."""
        name = task.name.strip()
        start = task.start
        duration = task.duration
        comment = task.comment

        if not name:
            raise Error("a task must have a name")
        if start:
            start = ISO.from_datetime(start)
            if not duration: duration = 0
        if duration: duration = ISO.seconds_to_duration(duration)

        string = cls.timed_format % (name, start, duration, comment) if start\
            else cls.timeless_format % (name, comment)
        return string.strip()


class ISO(object):
    """ISO handles conversion between formatted strings and
    datetimes (for date-times) and floats (for durations).

    ISO only creates a duration with components of accurate duration (hour,
    minute, second, but supports reading durations with components of nominal
    duration (year, month, day) by assuming 24 hours per day, 30 days per
    month, and 12 months per year.
    """

    isodatetime_regex = re.compile(
        r"""(?P<year> \d{4} ) - (?P<month> \d{2} ) - (?P<day> \d{2} )
        T (?P<hour> \d{2} ) : (?P<minute> \d{2} ) : (?P<second> \d{2} ) Z?""",
        re.U | re.X)
    isoduration_regex = re.compile(
        r"""P (?:(?P<Y> \d* )Y)? (?:(?P<M> \d+ )M)? (?:(?P<D> \d+ )D)?
        (?:T (?:(?P<TH> \d+ )H)? (?:(?P<TM> \d+ )M)? (?:(?P<TS> \d+ )S)?)?""",
        re.U | re.X)
    isodatetime_format = u"%04d-%02d-%02dT%02d:%02d:%02dZ"

    @classmethod
    def to_datetime(cls, isostring):
        """Returns the datetime corresponding to an ISO-8601 date-time string.

        Raises FormatError if the string format is bad."""
        match = cls.isodatetime_regex.match(isostring)
        if not match:
            raise FormatError("expected UTC ISO 8601 datetime", isostring)

        group = match.groupdict()
        dt = datetime(group['year'], group['month'], group['day'],
            group['hour'], group['minute'], group['second'])
        return dt

    @classmethod
    def from_datetime(cls, datetime):
        """Returns an ISO-8601-formatted string corresponding to datetime."""
        parts = (datetime.year, datetime.month, datetime.day,
            datetime.hour, datetime.minute, datetime.second)
        string = cls.isodatetime_format % parts
        return string

    @classmethod
    def duration_to_seconds(cls, isostring):
        """Returns a float representing the total seconds of the
        ISO-8601-formatted duration isostring.

        Raises FormatError on bad string format.
        """
        match = cls.isoduration_regex.match(isostring)
        # ISO 8601:2004(E) 4.4.3.2(c):
        # "at least one number and its designator shall be present"
        if not match or not match.groups():
            raise FormatError("expected UTC ISO 8601 duration", isostring)
        group = match.groupdict()
        year = group['Y'] or 0
        month = group['M'] or 0
        day = group['D'] or 0
        hour = group['TH'] or 0
        minute = group['TM'] or 0
        second = group['TS'] or 0
        seconds = second + 60*(minute + 60*(hour +
            24*(day + 30*(month + 12*year))))
        return seconds

    @staticmethod
    def seconds_to_duration(seconds):
        """Returns a unicode string of the ISO-8601-formatted duration
        corresponding to seconds.
        """
        minute, second = divmod(seconds, 60)
        hour, minute = divmod(minute, 60)
        parts = [u"PT"]
        if hour: parts.append(u"%02dH" % hour)
        if minute: parts.append(u"%02dM" % minute)
        # We have to have at least one unit, so ensure that there's at least
        # seconds, even if it's just 00S.
        parts.append(u"%02dS" % second)
        return u"".join(parts)


class Path(object):
    """Path is a place to stuff all the paths used by punch."""

    HOME = unicode(os.getenv("HOME", u"~"))
    """The user's home directory."""

    PUNCH = os.path.join(HOME, u".punch/")
    """The default punch directory, ~/.punch."""

    def __init__(self, tasks=u"tasks", times=u"times", current=u"current",\
        root=PUNCH):
        """Returns a new Path instance.

        Assigns root/{tasks,times,current} to the
        tasks, times, and current attributes.
        """
        self.tasks = os.path.join(root, tasks)
        self.times = os.path.join(root, times)
        self.current = os.path.join(root, current)


class Error(Exception):
    """Parent class of all exceptions thrown by punch."""
    pass


class FormatError(Error):
    def __init__(self, message, line=None, lineno=None):
        self.message = message
        self.line = line
        self.lineno = unicode(lineno)

    def __str__(self):
        parts = [self.message]
        if self.lineno:
            parts.insert(0, self.lineno)
        if self.line:
            parts.append(self.line)
        return u": ".join(parts)


class Punch(object):
    """Carries out the standard punch operations."""

    def __init__(self, path=Path()):
        self.path = path
        desc = u"The time tracker distinguished by its good taste."
        self.parser = argparse.ArgumentParser(description=desc)
        subparsers = self.parser.add_subparsers()

        tasks_parser = subparsers.add_parser('tasks')
        tasks_parsers = tasks_parser.add_subparsers()

        tasks_list_parser = tasks_parsers.add_parser('list')
        tasks_list_parser.set_defaults(run=self.tasks_list)

        tasks_add_parser = tasks_parsers.add_parser('add')
        tasks_add_parser.set_defaults(run=self.tasks_add)
        tasks_add_parser.add_argument('name', type=unicode,
            help="the new task's name - any space will be replaced by '-'")
        tasks_add_parser.add_argument('comment', nargs='*', type=unicode,
            help="the new task's comment (one line)")

        tasks_remove_parser = tasks_parsers.add_parser('remove')
        tasks_remove_parser.set_defaults(run=self.tasks_remove)
        tasks_remove_parser.add_argument('name-glob', nargs='+', type=unicode,
            help="the name of the task or tasks to remove")
        tasks_remove_parser.add_argument('--force', '-f', action='store_true',
            help="do not confirm the tasks to be removed")

    def handle(self, args):
        """Handles args as if provided on the commandline."""
        args = self.parser.parse_args(args)
        args.run(args)

    def tasks_list(self, args):
        with codecs.open(self.path.tasks, 'r', 'utf-8') as f:
            tasks = []
            try:
                tasks = TaskStream.read(f)
            except Error as e:
                print u'%s: %s:%s' % (self.parser.prog, self.path.tasks, e)
                return
            for task in tasks:
                print u'%s / %s' % (task.name, task.comment)

    def tasks_add(self, args):
        pass

    def tasks_remove(self, args):
        pass


def main():
    punch = Punch()
    try:
        punch.handle(sys.argv[1:])
    except KeyboardInterrupt:
        return


if __name__ == "__main__":
    main()
