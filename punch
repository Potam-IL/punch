#!/usr/bin/python
# vi: set et ts=4 sw=4 :
"""
Copyright (c) 2012, Jeremy W. Sherman
All rights reserved.

Distributed under the 3-clause BSD license.
See LICENSE at https://github.com/jeremy-w/punch.

Punch is a commandline time tracking tool.
Punch is:

- simple
- minimal

Punch's file format:

- human-readable, -editable, and -comprehensible
- easily computer-readable, -editable, and -comprehensible
- Unicode-friendly thanks to UTF-8
"""
import argparse
from datetime import datetime, timedelta
import fnmatch
import io
import math
import os
import re
from StringIO import StringIO
import shutil
import sys
import time


class Task(object):
    """A task represents a space-free name,
    a start time, UTC offset, and duration, and an optional free-form comment.

    Start is a datetime-offset pair.
    End is a datetime-offset pair.
    Duration is a float counting seconds between start and end.
    Comment is optional and defaults to the empty unicode string.

    Use ISO to format this info.
    Use TaskStream to read or write tasks.
    """
    def __init__(self, name, start=None, end=None, comment=u''):
        self.name = unicode(name) if name else None
        self.start = start
        self.end = end
        self.comment = unicode(comment) if comment else u''

    @classmethod
    def comment(cls, comment):
        """Creates a new comment task - a task that is purely a comment."""
        return cls(name=None, comment=comment)

    def __str__(self):
        """Returns a string with the elapsed time, name, and comment.

        Used when presenting a task to the user in response to an interactive
        command.
        """
        if self.is_comment:
            return self.comment
        s = self.duration or 0.0
        m, s = divmod(s, 60)
        h, m = divmod(m, 60)
        s = round(s)
        time = u''
        if h > 0:
            time = u'%dh%02dm%02ds ' % (h, m, s)
        elif m > 0 or s > 0:
            time = u'%dm%02ds ' % (m, s)
        return u'%s%s (%s)' % (time, self.name, self.comment)

    def __repr__(self):
        return u'Task(name=%s, start=%s, end=%s, comment=%s)'\
            % (self.name, self.start, self.duration, self.comment)

    @property
    def duration(self):
        if not self.start:
            return 0.0
        end = self.end
        if not end:
            end = ISO.pair_now()
        delta = ISO.pair_minus(end, self.start)
        return delta

    @property
    def is_comment(self):
        return not self.name


class TaskStream(object):
    """Task streams handle reading and writing tasks as strings.
    Each task is a single line.
    Blank lines and lines beginning with a # are skipped when reading.
    """
    # Three possible formats:
    # - timeless: name or name / comment, used in the tasks file
    # - timed: name start/duration comment?, used everywhere else
    # The real distinguishing factor of the timeless version is the
    # lack of characters before the /, where the start would be.
    timeless_regex = re.compile(r"""^(?:
          (?P<name> \S+ )
          (?: \s+ / \s* (?P<comment> .* ) )?
        )$""", re.U | re.X)
    timed_regex = re.compile(r"""^(?:
          (?P<name> \S+ ) \s+
          (?P<start> \S+ )/(?P<end_or_duration> \S+ )
          (?: \s+ (?P<comment> .+ ))?
          )$""", re.U | re.X)

    timeless_format = u"%s / %s"   # name and comment
    timed_format = u"%s %s/%s %s"  # name, start, end, comment

    @classmethod
    def read(cls, fileobj):
        """Reads a list of tasks from fileobj.
        Line parsing is done by TaskStream.parse().

        fileobj should be created by io.open(path, mode, encoding='utf-8').

        Raises FormatError on invalid task format.
        """
        tasks = []
        lineno = 0
        for line in fileobj:
            lineno += 1
            task = cls.parse(line, lineno)
            if task: tasks.append(task)
        return tasks

    @classmethod
    def write(cls, fileobj, *tasks):
        """Writes a sequence of tasks to fileobj.

        fileobj should be created by io.open(path, mode, encoding='utf-8').
        """
        for task in tasks:
            string = cls.format(task) + u"\n"
            fileobj.write(string)

    @classmethod
    def parse(cls, line, lineno=None):
        """Parses a task from a line of text.

        Raises whatever ISO.pair_from_string() or
        ISO.duration_to_seconds() raise.  Raises FormatError on invalid
        datetime or duration format.
        """
        line = line.strip()
        if not line or line.startswith('#'):
            return Task.comment(line)

        match = cls.timeless_regex.match(line)
        if match:
            name = match.group('name')
            comment = match.group('comment') or u''
            return Task(name=name, comment=comment)

        match = cls.timed_regex.match(line)
        if not match:
            raise FormatError("bad task format", line, lineno)

        name = match.group('name')
        comment = match.group('comment') or u''

        startstr = match.group('start')
        start = ISO.pair_from_string(startstr)

        endstr = match.group('end_or_duration')
        end = start
        if endstr.startswith('P'):
            duration = ISO.duration_to_seconds(endstr)
            end = (start[0] + timedelta(seconds=duration), start[1])
        else:
            end = ISO.pair_from_string(endstr)

        task = Task(name, start, end, comment)
        return task

    @classmethod
    def format(cls, task):
        """Formats a task for writing.

        Returns a unicode string.

        Raises Error if task.name is empty but not task.is_comment.
        Raises FormatError if start or duration cannot be formatted."""
        if task.is_comment:
            return task.comment
        name = task.name.strip()
        start_pair = task.start
        end_pair = task.end
        comment = task.comment

        if not name:
            raise Error("a task must have a name")
        start = None
        end = None
        if start_pair:
            start = ISO.pair_to_string(*start_pair)
            if end_pair is None:
                end = start
        if end_pair is not None:
            end = ISO.pair_to_string(*end_pair)

        string = None
        if start:
            string = cls.timed_format % (name, start, end, comment)
        else:
            string = cls.timeless_format % (name, comment)
        return string.strip()


class TaskTemplate(object):
    """Formats tasks per a template."""
    def __init__(self, template=u"{name} {hours/1u} {comment}"):
        """Initializes a formatter.

        Raises FormatError on bad template.
        """
        self.template = template

    def format(self, task):
        # TODO: Actually use template.
        return str(task)


class ISO(object):
    """ISO handles conversion between formatted strings and
    datetimes (for date-times) and floats (for durations).
    It also handles converting between duration formats.

    ISO only creates a duration with components of accurate duration (hour,
    minute, second, but supports reading durations with components of nominal
    duration (year, month, day) by assuming 24 hours per day, 30 days per
    month, and 12 months per year.
    """

    isodatetime_regex = re.compile(
        r"""(?P<year> \d{4} ) - (?P<month> \d{2} ) - (?P<day> \d{2} )
        T (?P<hour> \d{2} ) : (?P<minute> \d{2} ) : (?P<second> \d{2} )
        (?: Z | (?P<sign> \+|- ) (?P<dh> \d{2} ) : (?P<dm> \d{2} ) )""",
        re.U | re.X)
    isoduration_regex = re.compile(
        r"""P (?:(?P<Y> \d* )Y)? (?:(?P<M> \d+ )M)? (?:(?P<D> \d+ )D)?
        (?:T (?:(?P<TH> \d+ )H)? (?:(?P<TM> \d+ )M)? (?:(?P<TS> \d+ )S)?)?""",
        re.U | re.X)
    isodatetime_format = u"%04d-%02d-%02dT%02d:%02d:%02d%c%02d:%02d"

    @classmethod
    def utc_offset(cls):
        """Returns a float with the seconds local time is offset from UTC.

        Local time + offset = UTC time, so a time zone relative to UTC
        would have the opposite sign of offset.
        """
        now = time.time()
        local = datetime.fromtimestamp(now)
        utc = datetime.utcfromtimestamp(now)
        delta = utc - local
        seconds = float(round(delta.seconds + 86400 * delta.days))
        return seconds

    @classmethod
    def pair_from_string(cls, isostring):
        """Returns the datetime and UTC offset in seconds
        corresponding to an ISO-8601 date-time string.

        Raises FormatError if the string format is bad."""
        match = cls.isodatetime_regex.match(isostring)
        if not match:
            raise FormatError("expected UTC ISO 8601 datetime", isostring)

        group = match.groupdict()
        vals = [group['year'], group['month'], group['day'],
            group['hour'], group['minute'], group['second']]
        vals = [int(val) for val in vals]

        offset = 0.0
        sign = group['sign']
        if sign:
            h = float(group['dh'])
            m = float(group['dm'])
            offset = 60.0 * (m + 60.0 * h)
            if sign == '+':
                offset = -offset

        dt = datetime(*vals)
        return dt, offset

    @classmethod
    def pair_to_string(cls, datetime, offset):
        """Returns an ISO-8601-formatted string corresponding to datetime."""
        # offset is expressed relative to local time, but +/- sign is relative
        # to UTC, so we use the opposite sign you'd expect here
        sign = offset > 0 and '-' or '+'
        m, s = divmod(offset, 60)
        h, m = divmod(m, 60)
        parts = (datetime.year, datetime.month, datetime.day,
            datetime.hour, datetime.minute, datetime.second, sign, h, m)
        string = cls.isodatetime_format % parts
        return string

    @classmethod
    def duration_to_seconds(cls, isostring):
        """Returns a float representing the total seconds of the
        ISO-8601-formatted duration isostring.

        Raises FormatError on bad string format.
        """
        match = cls.isoduration_regex.match(isostring)
        # ISO 8601:2004(E) 4.4.3.2(c):
        # "at least one number and its designator shall be present"
        if not match or not match.groups():
            raise FormatError("expected UTC ISO 8601 duration", isostring)
        group = match.groupdict()
        year = int(group['Y'] or 0)
        month = int(group['M'] or 0)
        day = int(group['D'] or 0)
        hour = int(group['TH'] or 0)
        minute = int(group['TM'] or 0)
        second = float(group['TS'] or 0.0)
        seconds = second + 60.0*(minute + 60.0*(hour +
            24.0*(day + 30.0*(month + 12.0*year))))
        return seconds

    @staticmethod
    def seconds_to_duration(seconds):
        """Returns a unicode string of the ISO-8601-formatted duration
        corresponding to seconds.
        """
        minute, second = divmod(seconds, 60)
        hour, minute = divmod(minute, 60)
        parts = [u"PT"]
        if hour: parts.append(u"%02dH" % hour)
        if minute: parts.append(u"%02dM" % minute)
        # We have to have at least one unit, so ensure that there's at least
        # seconds, even if it's just 00S.
        parts.append(u"%02dS" % second)
        return u"".join(parts)

    @staticmethod
    def duration(start=None, stop=None, duration=None):
        """Supply any two, it computes and returns the third.

        start and stop should be Python datetimes.
        duration should be a Python float.

        Raises Error if other than 2 args are supplied."""
        count = len([a for a in [start, stop, duration] if a is not None])
        if count != 2:
            raise Error(u"ISO.duration: expected exactly 2 args, %d supplied"\
                % count)
        if not start:
            start = stop + timedelta(seconds=-duration)
            return start
        if not stop:
            stop = start + timedelta(seconds=duration)
            return stop
        if not duration:
            delta = stop - start
            duration = delta.seconds + 3600*delta.days
            if delta.microseconds:
                duration += 1
            return duration

    @classmethod
    def datetime_to_utc(cls, datetime, from_utc):
        """Converts datetime to a UTC datetime by adding the number of seconds
        in from_utc to it.
        """
        delta = timedelta(seconds=from_utc)
        utcdatetime = datetime + delta
        return utcdatetime

    @classmethod
    def pair_now(cls):
        """Returns the time now as (datetime, utc_offset) pair."""
        now_dt = datetime.now()
        now_offset = cls.utc_offset()
        return (now_dt, now_offset)

    @classmethod
    def pair_minus(cls, pair_left, pair_right):
        """Returns the seconds between the instants designated by
        pair_left and pair_right as a float.
        """
        left_utc = cls.datetime_to_utc(*pair_left)
        right_utc = cls.datetime_to_utc(*pair_right);
        start = right_utc
        stop = left_utc
        return cls.duration(start, stop)


class Path(object):
    """Path is a place to stuff all the paths used by punch."""

    HOME = unicode(os.getenv("HOME", u"~"))
    """The user's home directory."""

    PUNCH_DIR_DEFAULT = os.path.join(HOME, u".punch/")
    """The default root directory $PUNCHDIR (normally ~/.punch)."""

    PUNCH_DIR = unicode(os.getenv("PUNCH_DIR", PUNCH_DIR_DEFAULT))
    """The root directory - default can be overridden by environment."""

    def __init__(self, tasks=u"tasks", times=u"times", current=u"current",\
        root=PUNCH_DIR):
        """Returns a new Path instance.

        Assigns root/{tasks,times,current} to the
        tasks, times, and current attributes.

        If root is None, uses PUNCH_DIR.
        """
        self.root = root if root else type(self).PUNCH_DIR
        self.tasks = os.path.join(self.root, tasks)
        self.times = os.path.join(self.root, times)
        self.current = os.path.join(self.root, current)

    def __repr__(self):
        return u'Path(tasks=%s, times=%s, current=%s, root=%s)'\
            % (self.tasks, self.times, self.current, self.root)

    @staticmethod
    def backup(path):
        """Backs up 'path' to '.path~'.

        Does nothing if path does not exist.
        """
        if not os.path.exists(path):
            return
        parent = os.path.dirname(path)
        fnam = os.path.basename(path)
        target_name = u''.join(['.', fnam, '~'])
        target_path = os.path.join(parent, target_name)
        shutil.copy2(path, target_path)


class Error(Exception):
    """Parent class of all exceptions thrown by punch."""
    pass


class FormatError(Error):
    def __init__(self, message, line=None, lineno=None):
        self.message = message
        self.line = line
        self.lineno = unicode(lineno) if lineno else None

    def __str__(self):
        """Returns FormatError formatted as an error message:
            lineno: message: line
        Components of this message will be omitted if not provided.
        """
        parts = [self.message]
        if self.lineno:
            parts.insert(0, self.lineno)
        if self.line:
            parts.append(self.line)
        return u": ".join(parts)

    def __repr__(self):
        return u'FormatError(message=%s, line=%s, lineno=%s)'\
            % (self.message, self.line, self.lineno)


class Core(object):
    """Layer over Task, TaskStream, and Path."""
    def __init__(self, path=Path()):
        """Creates a new Core object."""
        self.path = path

    def current_task(self):
        """Returns the first (and only) task in self.path.current
        after updating its duration to match the current time.

        Returns None if the file does not exist or is empty.
        """
        if not os.path.isfile(self.path.current):
            return None
        with io.open(self.path.current, 'r', encoding='utf-8') as f:
            tasks = TaskStream.read(f)
            tasks = [t for t in tasks if not t.is_comment]
            if tasks:
                task = tasks[0]
                task.end = ISO.pair_now()
                return task
            return None

    def write_task_to_path(self, task, path, backup=True):
        """Writes |task| over |path|."""
        if backup: Path.backup(path)
        with io.open(path, 'w', encoding='utf-8') as f:
            TaskStream.write(f, task)

    def append_task_to_path(self, task, path):
        """Appends |task| to |path|."""
        with io.open(path, 'a', encoding='utf-8') as f:
            TaskStream.write(f, task)

    def read_tasks(self, path):
        """Returns all tasks in path.

        If an error is raised, prints it to stderr and returns None."""
        with io.open(path, 'r', encoding='utf-8') as f:
            tasks = []
            try:
                tasks = TaskStream.read(f)
                return tasks
            except Error as e:
                print >>sys.stderr, u'%s: error: %s:%s'\
                    % (self.prog, path, e)
                return None

    @staticmethod
    def tasks_matching_globs(tasks, globs):
        """Returns the list of tasks whose names match any of globs."""
        matches = []
        for glob in globs:
            matches += [t for t in tasks if fnmatch.fnmatch(t.name, glob)]
        return matches


class Punch(object):
    """Carries out the standard punch operations."""

    def __init__(self, path=Path()):
        """Creates self.parser and creates path.root."""
        desc = u"The time tracker distinguished by its good taste."
        self.parser = argparse.ArgumentParser(description=desc)
        self.prog = self.parser.prog
        subparsers = self.parser.add_subparsers()

        self.path = path
        if not os.path.exists(path.root):
            try:
                os.mkdir(path.root)
            except OSError as e:
                print >>sys.stderr,\
                    u"%s: error: cannot create punch directory %s: %s"\
                    % (self.prog, self.path.root, e)

        self.core = Core(path)

        self.add_tasks_parser(subparsers)
        self.add_times_parser(subparsers)
        in_parser = subparsers.add_parser('in',
            help="punch in the named task; "
            "if multiple tasks match, presents a list to choose from. "
            "Punches out first if you're currently punched in.")
        in_parser.set_defaults(run=self.punch_in_glob)
        in_parser.add_argument('nameglob', nargs='?', type=unicode,
            help="the task to check in for - "
            "multiple matches will be presented in a list; "
            "omit to choose from all tasks. "
            "If you are already punched in, you will be punched out first.")

        out_parser = subparsers.add_parser('out',
            help="punch out the current task")
        out_parser.set_defaults(run=self.punch_out)

        self.help = Help(self.path, self.prog)
        help_parser = subparsers.add_parser('help', help="detailed help")
        help_parser.set_defaults(run=self.help.help_on_topics)
        help_parser.add_argument('topic', nargs='*', type=unicode,
            help="topics to list detailed help for - "
            "omit to list all topics")

    def add_tasks_parser(self, subparsers):
        """Adds the parser tree responsible for handling
        `punch tasks` to |subparsers|.
        """
        tasks_parser = subparsers.add_parser('tasks',
            help='list, add, and remove tasks')
        tasks_parsers = tasks_parser.add_subparsers()

        tasks_list_parser = tasks_parsers.add_parser('list',
            help='list all tasks matching nameglob (default *)')
        tasks_list_parser.set_defaults(run=self.tasks_list)
        tasks_list_parser.add_argument('nameglob', nargs='*', type=unicode,
            help="task name glob")

        tasks_add_parser = tasks_parsers.add_parser('add',
            help='add a task')
        tasks_add_parser.set_defaults(run=self.tasks_add)
        tasks_add_parser.add_argument('name', type=unicode,
            help="the new task's name - any space will be replaced by '-'")
        tasks_add_parser.add_argument('comment', nargs='*', type=unicode,
            help="the new task's comment (one line)")

        tasks_remove_parser = tasks_parsers.add_parser('remove',
            help='remove tasks matching nameglob')
        tasks_remove_parser.set_defaults(run=self.tasks_remove)
        tasks_remove_parser.add_argument('nameglob', nargs='+', type=unicode,
            help="the name of the task or tasks to remove")
        tasks_remove_parser.add_argument('--force', '-f', action='store_true',
            help="do not confirm the tasks to be removed")

    def add_times_parser(self, subparsers):
        """Adds the parser tree responsible for handling
        `punch times` to |subparsers|.
        """
        times_parser = subparsers.add_parser('times',
            help='configurable display of recorded times')
        times_parser.set_defaults(run=self.punch_times)
        times_parser.add_argument('--after', '-a', type=unicode,
            metavar='DATETIME', help="list entries during or after DATETIME")
        times_parser.add_argument('--before', '-b', type=unicode,
            metavar='DATETIME', help="list entries during or before DATETIME")
        times_parser.add_argument('--on', '-o', type=unicode,
            metavar='DATETIME', help="list entries during DATETIME")
        times_parser.add_argument('--template', '-t', type=unicode,
            metavar='TEMPLATE', help="format entries using TEMPLATE",
            default=' {name} ({comment})')
        times_parser.add_argument('nameglob', nargs='?', type=unicode,
            metavar='NAMEGLOB', help="list entries with matching names",
            default='*')

    def punch_in_glob(self, args):
        """Reduces args to a single task and calls punch_in(task)
        after punching out any existing current task.
        """
        tasks = self.core.read_tasks(self.path.tasks)
        logged_error = tasks is None
        if logged_error: return
        if not tasks:
            print u'%s: no tasks found -- add some with `%s tasks add`'\
                % (self.prog, self.prog)
            return

        matches = self.core.tasks_matching_globs(tasks, [args.nameglob])\
            if args.nameglob else tasks
        if not matches:
            print u'%s: no task names match %s'\
                % (self.prog, args.nameglob)
            return
        count = len(matches)

        index = 0
        if count > 1:
            buf = StringIO()
            template = u'%%%dd: %%s\n' % (math.log(count, 10))
            for i, task in enumerate(matches):
                buf.write(template % (i + 1, task))
            buf.write(u'%s: enter a number to select a task: '\
                % (self.prog))
            val = raw_input(buf.getvalue())
            buf.close()

            # validate val to get index
            if not val:
                print u'%s: aborted' % (self.prog)
                return
            try:
                index = int(val) - 1
            except ValueError:
                print u'%s: error: not a number: %s' % (self.prog, val)
                return
            if not 0 <= index < count:
                print u'%s: error: must select 1-%d, not %d'\
                    % (self.prog, count, index + 1)
                return

        task = matches[index]
        current = self.core.current_task()
        if current:
            if task.name == current.name:
                print u'%s: already punched in: %s' % (self.prog, current)
                return
            self.punch_out()

        task.start = ISO.pair_now()
        self.core.write_task_to_path(task, self.path.current)
        print u'%s: punched in: %s' % (self.prog, task)

    def punch_out(self, args):
        """Appends the task from self.path.current to self.path.times
        and then removes self.path.current.
        """
        task = self.core.current_task()
        if not task:
            print u'%s: no current task to punch out' % (self.prog)
            return

        # We follow the task with a comment containing
        # the local date, hours (rounded to the half-hour), and total seconds.
        # This makes building a summary with an external tool easier.
        comment = u'#^ %0.2f h = %d s'
        secs = round(task.duration)
        hours = float(secs) / 3600.0
        comment = comment % (hours, secs)
        comment_task = Task.comment(comment)

        with io.open(self.path.times, 'a', encoding='utf-8') as f:
            TaskStream.write(f, task, comment_task)

        # Already copied sole entry to self.path.times,
        # so no need to make another backup before unlinking.
        os.unlink(self.path.current)
        print u'%s: punched out: %s' % (self.prog, task)

    def handle(self, args):
        """Handles args as if provided on the commandline."""
        if not args:
            self.list_current()
            return
        args = self.parser.parse_args(args)
        args.run(args)

    def list_current(self):
        """Lists the current task.

        This is the default behavior when invoked with no args."""
        task = self.core.current_task()
        if task:
            print u'%s: current task: %s' % (self.prog, task)
        else:
            print u'%s: no current task' % (self.prog)

    def tasks_list(self, args):
        tasks = self.core.read_tasks(self.path.tasks)
        logged_error = tasks is None
        if logged_error:
            return

        globs = args.nameglob
        if globs:
            tasks = self.core.tasks_matching_globs(tasks, globs)
        if not tasks:
            msg = u''.join([u'%s: no tasks found matching %s -- ',
                'add some with `%s tasks add`'])
            globstr = u' '.join(globs)
            print msg % (self.prog, globstr, self.prog)
            return
        for task in tasks:
            print unicode(task)

    def tasks_add(self, args):
        comment = u''
        if args.comment:
            comment = u' '.join(args.comment)
        task = Task(name=args.name, comment=comment)
        desc = TaskStream.format(task)
        self.core.append_task_to_path(task, self.path.tasks)
        print u'%s: added task: %s' % (self.prog, desc)

    def tasks_remove(self, args):
        tasks = self.core.read_tasks(self.path.tasks)
        if tasks is None:
            return

        to_remove = self.core.tasks_matching_globs(tasks, args.nameglob)
        count = len(to_remove)
        if not count:
            print u'%s: no task names match %s'\
                % (self.prog, u' '.join(*args.nameglob))
            return

        if not args.force:
            buf = StringIO()
            header = u'%s: found %d:\n' % (self.prog, count)
            buf.write(header)
            for task in to_remove:
                buf.write('    %s\n' % (TaskStream.format(task)))
            prompt = u'%s: (r)emove or (N)ot? ' % (self.prog)
            buf.write(prompt)
            reply = raw_input(buf.getvalue()).strip()
            buf.close()
            if not (reply and reply[0].lower() == 'r'):
                print u'%s: aborted' % (self.prog)
                return

        remainder = list(tasks)
        for task in to_remove:
            remainder.remove(task)
        Path.backup(self.path.tasks)
        with io.open(self.path.tasks, 'w', encoding='utf-8') as f:
            TaskStream.write(f, *remainder)
        print u'%s: removed %d' % (self.prog, count)

    def punch_times(self, args):
        """Lists time entries from self.path.times.

        The entries can be filtered by date using commandline options.
        The format used to print listed entries can be set using
        the --template option.
        """
        tasks = self.core.read_tasks(self.path.times)
        if tasks is None:
            return  # we already logged an error
        tasks = [t for t in tasks if not t.is_comment]
        if not tasks:
            msg = u"%s: no times found - punch in, then punch out to add times"
            print msg % (self.prog)
            return

        # FIXME: we need more lenient date-time parsing
        # At the very least, we need to allow just a date.
        # Perhaps add dependency on dateutil.parser?
        # http://labix.org/python-dateutil
        to_list = []
        after = None
        before = None
        if args.on:
            after = ISO.pair_from_string(args.on)
            before = ISO.pair_from_string(args.on)
        if args.after:
            after = ISO.pair_from_string(args.after)
        if args.before:
            before = ISO.pair_from_string(args.before)
        if not (after or before):
            to_list = tasks
        else:
            after_utc = ISO.datetime_to_utc(*after) if after else None
            before_utc = ISO.datetime_to_utc(*before) if before else None
            for task in tasks:
                start = task.start
                end = task.end
                start_utc = ISO.datetime_to_utc(*start)
                end_utc = ISO.datetime_to_utc(*end)
                excluded = (after_utc and end < after_utc
                    or before_utc and before_utc < start)
                if not excluded:
                    to_list.append(task)

        formatter = TaskTemplate()
        if args.template:
            formatter = TaskTemplate(args.template)

        parts = [u"times"]
        if after:
            parts.append(u"after %s" % ISO.pair_to_string(after))
        if after and before:
            parts.append(u"and")
        if before:
            parts.append(u"before %s" % ISO.pair_to_string(before))
        header = u' '.join(parts)
        header = u''.join([header, u':'])
        print header

        for task in to_list:
            line = formatter.format(task)
            print line

class Help(object):
    def __init__(self, path, prog):
        """Returns a new help object.

        Path is used to list current settings.
        Prog is used when referring to the program by name.
        """
        self.path = path
        self.prog = prog
        self.topics = [t[6:] for t in dir(self) if t.startswith('topic_')]

    def help_on_topics(self, args):
        """Help interface.

        Prints help for args.topic list. If no topics, defaults to 'topics'.
        """
        requested = args.topic
        valid = [t for t in requested if t in self.topics]
        invalid = [t for t in requested if not t in valid]
        if invalid:
            splat = (self.prog, u' '.join(invalid))
            print >>sys.stderr, u'%s: warning: topics do not exist: %s' % splat
        if valid:
            method_names = ['topic_' + topic for topic in valid]
            for method_name in method_names:
                bound_method = getattr(self, method_name)
                print bound_method()
        else:
            print self.topic_topics()

    def topic_topics(self):
        """you're reading it now"""
        header = u"%s: available help topics:\n\n" % (self.prog)
        footer = u"\nNew to %s? Check out walkthrough, concepts, and files."
        footer = footer % (self.prog)
        buf = StringIO()
        buf.write(header)
        for topic in self.topics:
            m = getattr(self, 'topic_' + topic)
            desc = m.__doc__
            buf.write(u'  %s -- %s\n' % (topic, desc))
        buf.write(footer)
        msg = buf.getvalue()
        buf.close()
        return msg

    def topic_walkthrough(self):
        """basic setup and use"""
        h = """Welcome to %s!

%S tracks and summarizes the time you spend on tasks. It's a combination
punch-clock and timesheet.

A task has a one-word name and a one-line comment. Create a couple now with:

    %s tasks add name the rest is a comment
    %s tasks add %s-walkthrough how I learned to use %s
    %s tasks add cocktail-hour man was that a blast

Let's make sure they're there:

    %s tasks list

Hmm, maybe we don't want to clock our drinking time. Let's remove that
task:

    %s tasks remove cockt*

See that `cockt*`? Several %s commands accept "globs", which make it
easy to specify tasks without having to type too much. They also let you
create your own simple task hierarchy using unique prefixes. Read more
at `%s help globs`.

Confirm the removal by typing 'r', and list again:

    %s tasks list

There, that's more like it.

Now, punch in:

    %s in

Enter a number to choose a task. You can also provide a glob to shorten
the list. If the glob only leaves one task, you get to skip the list.

Check what you're punched in on by calling %s with no arguments:

    %s

Now punch out with:

    %s out

You'll see a summary of how long you were clocked in.

You can view your time entries like so:

    %s times

There! Now you know how to use %s to track your time with style."""
        h = h.replace('%s', self.prog)
        h = h.replace('%S', self.prog.title())
        return h

    def topic_what(self):
        """a more complete description"""
        h =\
"""%s tracks time spent on tasks. To %s, a time entry comprises:

- task name: do-something
- start date-time: 2012-12-12T14:14:14
- offset from UTC, appended to the date-time: -05:00
- duration: PT3H4M5S, meaning 3 hours, 4 minutes, 5 seconds
- optional comment: that took longer than expected

The name is a single word. The comment is a single line of text.
These are what you provide to `%s tasks add`.

When you punch in, the start and UTC-offset get set.

start is a local date-time. Local date-times don't mean much without
a time zone, and time zones change. So instead of relying on local
date-time, %s stores the offset at that moment from UTC. UTC is a
universal timescale that uniquely identifies a point in time.

Punch in pulls names and comments from the tasks file. When you select one,
it sets its start and offset and writes it to the current file. When you
punch out, it reads in the current task, computes the duration, and
appends the time entry to the times file."""
        h = h.replace('%s', self.prog)
        return h

    def topic_files(self):
        """files and file formats"""
        h =\
"""# FILES
%S only uses three files:

- tasks -- task names and default comments
- current -- the in-progress task with name, comment, and start time
- times -- a record of all tasks punched in and out, including the time
           clocked in on a specific task

The files' location is determined by the PUNCH_DIR environment variable.
The default value for PUNCH_DIR is $HOME/.punch.

The first time you run %s, it creates PUNCH_DIR to store all your task
and time info. It's hidden to keep it out of your way, but you should
feel free to poke through it at any time -- %s intentionally keeps its
files human-readable.

# FORMATS
tasks:

    <name> / <comment>

current and times:

    <name> <date-time>/<duration> <comment>

The tokens used in the format above are:

    <name> = one or more non-whitespace characters
    <comment> = zero or more non-newline characters

    <date-time> = <year>-<month>-<day>T<hour>:<minute><offset>
    <offset>= +<hour>:<minute> or -<hour>:<minute>

    <duration> = PT<hour>H<minute>M<second>S
        <hour>H is omitted if the duration is less than 1 hour.
        <minute>M is omitted if the duration is less than 1 minute.

    <year> = 4 decimal digits
    <day>, <hour>, <minute> = 2 decimal digits"""
        h = h.replace('%s', self.prog)
        h = h.replace('%S', self.prog.title())
        return h

    def topic_glob(self):
        """globs used by task list, task remove, times"""
        h =\
"""%s uses file-style globs to match tasks and comments. The syntax is
straightforward:

    *      matches any number of characters
    ?      matches a single character
    [...]  matches any character in between [ and ]
    [!...] matches any character except those between [! and ]

So given:

    task-1 task-2 task-33

The following patterns will match:

    task-?    => task-1 task-2
    task-*    => task-1 task-2 task-33
    task-[12] => task-1 task-2
    task-[!1] => task-2"""
        h = h.replace('%s', self.prog)
        return h

    def topic_template(self):
        """template syntax used by times --template option"""
        return "under construction"

    def topic_tips(self):
        """non-obvious uses"""
        h = """# Switch Out PUNCH_DIR
Track your work-time and play-time separately by changing PUNCH_DIR:

    PUNCH_DIR=~/.homepunch
    %s tasks add party-hard social
    %s tasks add study-hard mental
    %s tasks add run-hard physical
    PUNCH_DIR=~/.punch
    %s tasks add file-tps-reports bigcorp"""
        h = h.replace('%s', self.prog)
        return h


def main():
    punch = Punch()
    try:
        punch.handle(sys.argv[1:])
    except KeyboardInterrupt:
        return


if __name__ == "__main__":
    main()
