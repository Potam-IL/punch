#!/usr/bin/python
# vi: set et ts=4 sw=4 :
"""
Implements two tools for time tracking:

- punch-in -- gives you a selection of tasks and starts
  timing the one you choose
- punch-out -- looks up the current task, calculates the time elapsed,
  and appends that info to the timesheet

Files stored under $PUNCH_DIR (default ~/.punch):

- tasks -- the list of tasks

  The file format is three space-delimited fields:

    - task id
    - task name
    - comment (optional)

- current -- the current task and its start time

  The file format is '<task-id> <start-timestamp>'.

- timesheet -- an append-only log of time entries

  The file format treats lines beginning with # as a comment.
  Blank lines are also ignored. The lines that matter have two
  space-delimited fields:

    - task id
    - start timestamp
    - end timestamp

"""

import errno
import os
import re
import sys
import time


class Config(object):
    """Path information used throughout punch."""

    def __init__(self, tasks_path, timesheet_path, current_task_path):
        self.tasks_path = tasks_path
        self.timesheet_path = timesheet_path
        self.current_task_path = current_task_path

    @classmethod
    def default(cls):
        return cls.under(cls.default_directory())

    @staticmethod
    def default_directory():
        home = os.getenv('HOME', '~')
        punch_dir = os.getenv('PUNCH_DIR', os.path.join(home, '.punch'))
        return punch_dir

    @classmethod
    def under(cls, parent_dir):
        """Returns a Config where the paths are under a parent directory."""
        names = ['tasks', 'timesheet', 'current']
        paths = [os.path.join(parent_dir, name) for name in names]
        try:
            os.mkdir(parent_dir)
        except OSError as e:
            if e.errno != errno.EEXIST:
                raise
        return cls(*paths)


class Task(object):
    def __init__(self, name, id, comment='', start=None, stop = None):
        self.name = name
        self.id = int(id)
        self.comment = comment
        self.time_start = start or time.time()
        self.time_stop = stop or self.time_start

    def __repr__(self):
        return 'Task(%s, %d, %s, %s, %s)'\
            % (self.name, self.id, self.comment,
               self.time_start, self.time_stop)

    def __str__(self):
        return '%s/%s (%s)' % (self.name, self.id, self.comment)

    def seconds(self):
        return self.time_stop - self.time_start

    def day(self):
        """Returns a string representing the local date as of time_start."""
        info = time.localtime(self.time_start)
        day = time.strftime('%Y-%m-%d', info)
        return day


class Puncher(object):
    def __init__(self, config=Config.default()):
        self.config = config

    def punch_in(self, task):
        """Punches in.

        WARNING: This overwrites |current_task_path|.
        Be sure to punch out any current task.
        """
        entry = CurrentTask.format_task(task)
        with open(self.config.current_task_path, 'w') as f:
            print >>f, entry

    def punch_out(self, task):
        """Appends a time entry to config.timesheet_path.

        If task.id matches current_task.id, unlinks config.current_task_path.
        """
        with open(self.config.timesheet_path, 'a') as f:
            entry = Timesheet.format_task(task)
            f.write(entry)

        ctask = CurrentTask(self.config).task()
        if ctask and ctask.id == task.id:
            os.unlink(self.config.current_task_path)


class FormatError(Exception):
    def __init__(self, message):
        self.message = message

class FileFormatError(FormatError):
    def __init__(self, path, lineno, text, message=''):
        self.path = path
        self.lineno = lineno
        self.text = text

    def __str__(self):
        m = '%s:%d: bad format in text: %s'\
            % (self.path, self.lineno, self.text)
        if self.message:
            m = '\n'.join(m, self.message)
        return m


class CurrentTask(object):
    """Centralizes information needed to read/write the current_task file."""

    def __init__(self, config):
        """Returns a new CurrentTask."""
        self.config = config

    def path(self):
        return self.config.current_task_path

    def parse_task(self, line):
        (task_id, start) = line.strip().split()
        task_id = int(task_id)
        start = int(start)

        tasks = Tasks(self.config).tasks()
        matches = filter(lambda t: t.id == task_id, tasks)
        if not matches:
            raise LookupError('current task id %d matches no task'\
                % (task_id))

        m = matches[0]
        stop = time.time()
        task = Task(m.name, m.id, m.comment, start, stop)
        return task

    @staticmethod
    def format_task(task):
        """Formats |task| as a current task entry."""
        return '%d %d' % (task.id, task.time_start)

    def task(self):
        if not os.path.exists(self.path()):
            return None

        with open(self.path()) as f:
            line = f.readline()
            if not line:
                return None

            task = self.parse_task(line)
            return task

class Tasks(object):
    def __init__(self, config):
        self.config = config
        self._tasks = []

    def path(self):
        return self.config.tasks_path

    def tasks(self, force=False):
        if self._tasks and not force:
            return self._tasks

        self._tasks = []
        if not os.path.exists(self.path()):
            return self._tasks

        with open(self.path()) as f:
            i = 0
            line = f.readline()
            while line:
                i += 1
                try:
                    task = self.parse_task(line)
                    self._tasks.append(task)
                except:
                    self._tasks = []
                    raise FileFormatError(self.path(), i, line)
                line = f.readline()
        return self._tasks

    @staticmethod
    def parse_task(line):
        line = line.strip()
        line = re.sub('\s+', ' ', line)
        vals = line.split(' ', 2)
        task = Task(*vals)
        return task

    @classmethod
    def format_task(cls, task):
        """Formats |task| as a task table entry."""
        cls.validate_task(task)
        return '%s %s %s' % (task.name, task.id, task.comment)

    @classmethod
    def validate_task(cls, task):
        if task.name.find(' ') != -1:
            raise FormatError('%s: task name must not have spaces' % task)
        if task.id.find(' ') != -1:
            raise FormatError('%s: task id must not have spaces' % task)
        if task.comment.find('\n') != -1:
            raise FormatError('%s: task comment must have no newlines' % task)


class Timesheet(object):
    """Centralizes information needed to read/write the timesheet file."""

    def __init__(self, config):
        """Returns a new Timesheet."""
        self.config = config

    def path(self):
        return self.config.timesheet_path

    def tasks(self):
        if not os.path.exists(self.path()):
            print 'punch-summary: timesheet #{TIMESHEET_PATH} does not exist'
            return []

        all_tasks = Tasks(self.config).tasks()
        with open(self.path()) as f:
            line = f.readline()
            tasks = []
            i = 0
            while line:
                i += 1
                try:
                    task = self.parse_task(line, tasks=all_tasks)
                    if task:
                        tasks.append(task)
                except Exception as e:
                    e2 = FileFormatError(self.path(), i, line, e.message)
                    raise e2
                line = f.readline()
            return tasks

    @staticmethod
    def format_task(task):
        """Formats |task| as a timesheet entry."""
        (h, m, s) = seconds_to_hours(task.seconds())
        elapsed = '%d:%02d:%05.2f' % (h, m, s)
        entry = '# %s - %s - %s\n%d %d %d\n\n'\
            % (task.day(), task, elapsed,\
               task.id, task.time_start, task.time_stop)
        return entry

    def parse_task(self, line, tasks=None):
            # Skip blank lines and comments.
            line = line.strip()
            if not line or line.startswith('#'):
                return None

            parts = line.split()
            if len(parts) != 3:
                raise FormatError('expected 3 space-separated parts')

            (task_id, start, stop) = parts
            task_id = int(task_id)
            start = float(start)
            stop = float(stop)

            if tasks is None:
                tasks = Tasks(self.config).tasks()
            matches = filter(lambda t: t.id == task_id, tasks)
            if not matches:
                raise LookupError('no task found with id %d' % (task_id))

            m = matches[0]
            task = Task(m.name, m.id, m.comment, start, stop)
            return task


def main_punch_in(puncher):
    try:
        tasks = Tasks(puncher.config).tasks()
    except FormatError as e:
        print >>sys.stderr, 'punch-in:', e
        return

    if not tasks:
        print 'punch-in: no tasks found'
        return

    print "select a task:"
    for i, task in enumerate(tasks):
        print '%d: %s (%s)' % (i, task.name, task.comment)
    line = raw_input()
    choice = int(line)
    # FIXME: Assuming the user selected a valid number here.
    task = tasks[choice]

    main_punch_out(puncher, False)
    puncher.punch_in(task)


def main_punch_now(config):
    task = CurrentTask(config).task()
    if task:
        hours, mins, secs = seconds_to_hours(task.seconds())
        print 'punch-now: %s - %d:%02d:%02d' % (task, hours, mins, secs)
    else:
        print 'punch-now: no current task'


def seconds_to_hours(secs):
    mins = int(secs) / 60
    secs -= 60*mins
    hours = mins / 60
    mins -= 60*hours
    return (hours, mins, secs)


def main_punch_out(puncher, warn=True):
    task = CurrentTask(puncher.config).task()
    if task:
        puncher.punch_out(task)
        hours, mins, secs = seconds_to_hours(task.seconds())
        print 'punch-out: %s - %d:%02d:%02d' % (task, hours, mins, secs)
    elif warn:
        print 'punch-out: no current task'


def group_tasks_by_day(tasks):
    tasks.sort(key=lambda t: t.time_start)
    tasks_by_day = []
    day = tasks[0].day()
    day_tasks = []
    for task in tasks:
        if task.day() == day:
            day_tasks.append(task)
        else:
            day = task.day()
            if day_tasks: tasks_by_day.append(day_tasks)
            day_tasks = [task]
    if day_tasks:
        tasks_by_day.append(day_tasks)
    return tasks_by_day


def main_punch_summary(config):
    tasks = Timesheet(config).tasks()
    if not tasks:
        print 'punch-summary: no entries found'
        return

    entries_by_day = group_tasks_by_day(tasks)

    # reduce to one task entry per day
    def combine_time(id_map, task):
        canon = id_map.get(task.id, None)
        if canon:
            canon.time_stop += task.seconds()
        else:
            id_map[task.id] = task
        return id_map

    tasks_by_day = []
    for group in entries_by_day:
        tasks_by_id = reduce(combine_time, group, dict())
        tasks = tasks_by_id.values()
        tasks_by_day.append(tasks)

    # report
    def format_task(task):
        (hours, mins, secs) = seconds_to_hours(task.seconds())
        h = float(hours)
        if mins > 30:
            h += 1
        elif mins > 0 or secs > 0:
            h += 0.5
        desc = '%s %0.1f %s %s (%s)' \
            % (task.day(), h, task.id, task.name, task.comment)
        return desc
    for group in tasks_by_day:
        day = group[0].day()
        for task in group:
            print format_task(task)

def main():
    puncher = Puncher()

    name = sys.argv[0]
    if name.endswith('in'):
        main_punch_in(puncher)
    elif name.endswith('out'):
        main_punch_out(puncher)
    elif name.endswith('mary'):
        main_punch_summary(puncher.config)
    else:
        main_punch_now(puncher.config)


if __name__ == "__main__":
    main()
